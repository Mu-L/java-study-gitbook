(window.webpackJsonp=window.webpackJsonp||[]).push([[844],{1221:function(s,e,t){"use strict";t.r(e);var r=t(26),a=Object(r.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"redis面试-应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis面试-应用场景"}},[s._v("#")]),s._v(" Redis面试-应用场景")]),s._v(" "),t("h2",{attrs:{id:"_1-redis-客户端有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis-客户端有哪些"}},[s._v("#")]),s._v(" 1 Redis 客户端有哪些？")]),s._v(" "),t("p",[s._v("Redisson、Jedis、lettuce等等，官方推荐使用Redisson。")]),s._v(" "),t("p",[s._v("Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。")]),s._v(" "),t("h2",{attrs:{id:"_2-redis如何做大量数据插入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis如何做大量数据插入"}},[s._v("#")]),s._v(" 2 Redis如何做大量数据插入？")]),s._v(" "),t("p",[s._v("Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。")]),s._v(" "),t("h2",{attrs:{id:"_3-redis实现分布式锁实现-什么是-redlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis实现分布式锁实现-什么是-redlock"}},[s._v("#")]),s._v(" 3 Redis实现分布式锁实现? 什么是 RedLock?")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("常规")])])]),s._v(" "),t("p",[s._v("加锁： SET NX PX + 校验唯一随机值")]),s._v(" "),t("p",[s._v("解锁： Lua脚本")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("RedLock")])])]),s._v(" "),t("p",[s._v("搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Redisson框架")])])]),s._v(" "),t("p",[s._v("Redisson watchdog或者它实现了RedLock方式")]),s._v(" "),t("p",[s._v("具体可以看后文分布式锁中实现方式。")]),s._v(" "),t("h2",{attrs:{id:"_4-redis缓存有哪些问题-如何解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis缓存有哪些问题-如何解决"}},[s._v("#")]),s._v(" 4 Redis缓存有哪些问题，如何解决？")]),s._v(" "),t("p",[s._v("当缓存库出现时，必须要考虑如下问题：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("缓存穿透")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("问题来源")]),s._v(": 缓存穿透是指"),t("strong",[s._v("缓存和数据库中都没有的数据")]),s._v("，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。")]),s._v(" "),t("li",[s._v("解决方案\n"),t("ul",[t("li",[s._v("接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；")]),s._v(" "),t("li",[s._v("从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击")]),s._v(" "),t("li",[s._v("布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小")])])])])]),s._v(" "),t("li",[t("strong",[s._v("缓存穿击")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("问题来源")]),s._v(": 缓存击穿是指"),t("strong",[s._v("缓存中没有但数据库中有的数据")]),s._v("（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。")]),s._v(" "),t("li",[s._v("解决方案\n"),t("ul",[t("li",[s._v("设置热点数据永远不过期。")]),s._v(" "),t("li",[s._v("接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务  不可用时候，进行熔断，失败快速返回机制。")]),s._v(" "),t("li",[s._v("加互斥锁")])])])])]),s._v(" "),t("li",[t("strong",[s._v("缓存雪崩")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("问题来源")]),s._v(": 缓存雪崩是指缓存中"),t("strong",[s._v("数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机")]),s._v("。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。")]),s._v(" "),t("li",[s._v("解决方案\n"),t("ul",[t("li",[s._v("缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。")]),s._v(" "),t("li",[s._v("如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。")]),s._v(" "),t("li",[s._v("设置热点数据永远不过期。")])])])])]),s._v(" "),t("li",[t("strong",[s._v("缓存污染")]),s._v("（或者满了）")])]),s._v(" "),t("p",[s._v("缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。")]),s._v(" "),t("p",[s._v("缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。")]),s._v(" "),t("h2",{attrs:{id:"_5-redis性能问题有哪些-如何分析定位解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-redis性能问题有哪些-如何分析定位解决"}},[s._v("#")]),s._v(" 5 Redis性能问题有哪些，如何分析定位解决?")]),s._v(" "),t("p",[s._v("举几个例子")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("看延迟")]),s._v(" 60 秒内的最大响应延迟：")])]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ redis-cli -h "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1 -p "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("6379")]),s._v(" --intrinsic-latency "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("60")]),s._v("\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("18")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("31")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("32")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("59")]),s._v(" microseconds.\nMax latency so far: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("72")]),s._v(" microseconds.\n \n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1428669267")]),s._v(" total runs "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("avg latency: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.0420")]),s._v(" microseconds / "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("42.00")]),s._v(" nanoseconds per run"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(".\nWorst run took 1429x longer than the average latency.\n   \n")])])]),t("ul",[t("li",[t("strong",[s._v("慢日志")]),s._v("（slowlog）")])]),s._v(" "),t("p",[s._v("慢查询，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220628231317888.png",alt:"image-20220628231317888"}})]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("bigkey")])])]),s._v(" "),t("p",[s._v("大对象")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("集中过期")])])]),s._v(" "),t("p",[s._v("一般有两种方案来规避这个问题：")]),s._v(" "),t("ol",[t("li",[s._v("集中过期 key 增加一个随机过期时间，把集中过期的时间打散，降低 Redis 清理过期 key 的压力")]),s._v(" "),t("li",[s._v("如果你使用的 Redis 是 4.0 以上版本，可以开启 lazy-free 机制，当删除过期 key 时，把释放内存的操作放到后台线程中执行，避免阻塞主线程")])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("fork耗时严重")])])]),s._v(" "),t("p",[s._v("主进程创建子进程，会调用操作系统提供的 fork 函数")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("使用Swap")])])]),s._v(" "),t("p",[s._v("当内存中的数据被换到磁盘上后，Redis 再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍！")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("内存碎片")])])]),s._v(" "),t("p",[s._v("Redis 4.0 版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理")])])}),[],!1,null,null,null);e.default=a.exports}}]);