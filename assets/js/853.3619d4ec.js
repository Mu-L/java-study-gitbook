(window.webpackJsonp=window.webpackJsonp||[]).push([[853],{1229:function(e,s,_){"use strict";_.r(s);var t=_(26),v=Object(t.a)({},(function(){var e=this,s=e.$createElement,_=e._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"为什么redis能这么快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么redis能这么快"}},[e._v("#")]),e._v(" 为什么redis能这么快?")]),e._v(" "),_("h2",{attrs:{id:"_1-有多快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-有多快"}},[e._v("#")]),e._v(" 1. 有多快")]),e._v(" "),_("p",[e._v("redis 支持10W+QPS(QPS 既query per second。每秒内查询的次数)")]),e._v(" "),_("h2",{attrs:{id:"_2-为什么能这么快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么能这么快"}},[e._v("#")]),e._v(" 2. 为什么能这么快？")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("内存存储：纯内存操作，内存的读写速度非常快（不会受到硬盘IO限制）")])]),e._v(" "),_("li",[_("p",[e._v("数据结构简单：redis不使用表，数据不用预定义")]),e._v(" "),_("blockquote",[_("p",[e._v("redis不使用表，数据不用预定义。不强制用户与存储数据进行关联")])])]),e._v(" "),_("li",[_("p",[e._v("单线程实现：redis使用单个线程处理请求，避免了多个线程之间线程切换和锁竞争")]),e._v(" "),_("blockquote",[_("ul",[_("li",[_("p",[e._v("为什么是单线程：")])]),e._v(" "),_("li",[_("p",[e._v("Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小（官方文档）")])]),e._v(" "),_("li",[_("p",[e._v("单线程切换开销小，容易实现")])]),e._v(" "),_("li",[_("p",[e._v("如果万一CPU成为你redis的瓶颈，或者不想让其他核闲置怎么办？")])]),e._v(" "),_("li",[_("p",[e._v("多起几个redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。"),_("strong",[e._v("redis-cluster")]),e._v("可以帮你做的更好。")])]),e._v(" "),_("li",[_("p",[e._v("Redis Server运行的时候是单线程吗")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理")])])]),e._v(" "),_("li",[_("p",[e._v("Redis进行持久化的时候会以子进程或者子线程的方式执行")])])])])]),e._v(" "),_("li",[_("p",[e._v("非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现")]),e._v(" "),_("blockquote",[_("p",[e._v("等待用户的读写操作都是阻塞的，io操作往往不能直接返回，io多路复用就解决这个问题")]),e._v(" "),_("p",[e._v("IO多路复用的具体实现select/epoll 等")]),e._v(" "),_("ol",[_("li",[e._v("select/epoll在 单个process就可以同时处理多个网络连接的IO。")]),e._v(" "),_("li",[e._v("select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程")])])])])])])}),[],!1,null,null,null);s.default=v.exports}}]);