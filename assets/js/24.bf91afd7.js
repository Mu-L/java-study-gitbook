(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{400:function(a,s,t){"use strict";t.r(s);var n=t(26),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"负载均衡算法-汇总"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡算法-汇总"}},[a._v("#")]),a._v(" 负载均衡算法-汇总")]),a._v(" "),t("h2",{attrs:{id:"_1-常见的负载均衡算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-常见的负载均衡算法"}},[a._v("#")]),a._v(" 1. 常见的负载均衡算法")]),a._v(" "),t("p",[a._v("常见的负载均衡算法包含:")]),a._v(" "),t("ul",[t("li",[a._v("轮询法(Round Robin)")]),a._v(" "),t("li",[a._v("加权轮询法(Weight Round Robin)")]),a._v(" "),t("li",[a._v("平滑加权轮询法(Smooth Weight Round Robin)")]),a._v(" "),t("li",[a._v("随机法(Random)")]),a._v(" "),t("li",[a._v("加权随机法(Weight Random)")]),a._v(" "),t("li",[a._v("源地址哈希法(Hash)")]),a._v(" "),t("li",[a._v("最小连接数法(Least Connections)")])]),a._v(" "),t("h3",{attrs:{id:"_1-1-轮询法-round-robin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-轮询法-round-robin"}},[a._v("#")]),a._v(" 1.1 轮询法(Round Robin)")]),a._v(" "),t("p",[a._v("将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。")]),a._v(" "),t("h3",{attrs:{id:"_1-2-加权轮询法-weight-round-robin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-加权轮询法-weight-round-robin"}},[a._v("#")]),a._v(" 1.2 加权轮询法(Weight Round Robin)")]),a._v(" "),t("p",[a._v("不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。")]),a._v(" "),t("h3",{attrs:{id:"_1-3-随机法-random"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-随机法-random"}},[a._v("#")]),a._v(" 1.3 随机法(Random)")]),a._v(" "),t("p",[a._v("通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。")]),a._v(" "),t("h3",{attrs:{id:"_1-4-加权随机法-weight-random"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-加权随机法-weight-random"}},[a._v("#")]),a._v(" 1.4 加权随机法(Weight Random)")]),a._v(" "),t("p",[a._v("与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。")]),a._v(" "),t("h3",{attrs:{id:"_1-5-源地址哈希法-hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-源地址哈希法-hash"}},[a._v("#")]),a._v(" 1.5 源地址哈希法(Hash)")]),a._v(" "),t("p",[a._v("源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。")]),a._v(" "),t("h3",{attrs:{id:"_1-6-最小连接数法-least-connections"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-最小连接数法-least-connections"}},[a._v("#")]),a._v(" 1.6 最小连接数法(Least Connections)")]),a._v(" "),t("p",[a._v("最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。")]),a._v(" "),t("h2",{attrs:{id:"_2-nginx的5种负载均衡算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-nginx的5种负载均衡算法"}},[a._v("#")]),a._v(" 2. Nginx的5种负载均衡算法")]),a._v(" "),t("h3",{attrs:{id:"_2-1-轮询法-round-robin-默认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-轮询法-round-robin-默认"}},[a._v("#")]),a._v(" 2.1 轮询法(Round Robin)(默认)")]),a._v(" "),t("p",[a._v("每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。")]),a._v(" "),t("h3",{attrs:{id:"_2-2-加权轮询法-weight-round-robin-weight"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-加权轮询法-weight-round-robin-weight"}},[a._v("#")]),a._v(" 2.2 加权轮询法(Weight Round Robin)- weight")]),a._v(" "),t("p",[a._v("指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。")]),a._v(" "),t("p",[a._v("例如:")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("upstream bakend "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.14 "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("weight")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.15 "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("weight")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n\n  \n")])])]),t("h3",{attrs:{id:"_2-3-源地址哈希法-hash-ip-hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-源地址哈希法-hash-ip-hash"}},[a._v("#")]),a._v(" 2.3 源地址哈希法(Hash)- ip_hash")]),a._v(" "),t("p",[a._v("每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。")]),a._v(" "),t("p",[a._v("例如:")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("upstream bakend "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n  ip_hash"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.14:88"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".0.15:80"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h3",{attrs:{id:"_2-4-fair-第三方"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-fair-第三方"}},[a._v("#")]),a._v(" 2.4 fair(第三方)")]),a._v(" "),t("p",[a._v("按后端服务器的响应时间来分配请求，响应时间短的优先分配。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("upstream backend "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n  server server1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server server2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  fair"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("h3",{attrs:{id:"_2-5-url-hash-第三方"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-url-hash-第三方"}},[a._v("#")]),a._v(" 2.5 url_hash(第三方)")]),a._v(" "),t("p",[a._v("按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。")]),a._v(" "),t("p",[a._v("例: 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("upstream backend "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n  server squid1:3128"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server squid2:3128"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("hash")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$request_uri")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  hash_method crc32"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" \n")])])]),t("p",[a._v("tips:")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("upstream bakend"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("#定义负载均衡设备的Ip及设备状态  \n  ip_hash"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:9090 down"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:8080 "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("weight")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:6060"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n  server "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("127.0")]),a._v(".0.1:7070 backup"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("在需要使用负载均衡的server中增加")]),a._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[a._v("proxy_pass http://bakend/"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n")])])]),t("p",[a._v("每个设备的状态设置为:")]),a._v(" "),t("ul",[t("li",[a._v("down 表示单前的server暂时不参与负载")]),a._v(" "),t("li",[a._v("weight 默认为1.weight越大，负载的权重就越大。")]),a._v(" "),t("li",[a._v("max_fails : 允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误")]),a._v(" "),t("li",[a._v("fail_timeout:max_fails次失败后，暂停的时间。")]),a._v(" "),t("li",[a._v("backup:  其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。")])]),a._v(" "),t("p",[a._v("nginx支持同时设置多组的负载均衡，用来给不用的server来使用。")]),a._v(" "),t("ul",[t("li",[a._v("client_body_in_file_only: 设置为On，可以讲client post过来的数据记录到文件中用来做debug。")]),a._v(" "),t("li",[a._v("client_body_temp_path: 设置记录文件的目录，可以设置最多3层目录。")]),a._v(" "),t("li",[a._v("location: 对URL进行匹配，可以进行重定向或者进行新的代理，负载均衡。")])]),a._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://pdai.tech/md/algorithm/alg-domain-load-balance.html",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[a._v("负载均衡算法 - 汇总")]),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);