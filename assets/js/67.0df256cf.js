(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{441:function(t,_,v){"use strict";v.r(_);var a=v(26),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"java如何选择合适的垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java如何选择合适的垃圾回收器"}},[t._v("#")]),t._v(" Java如何选择合适的垃圾回收器")]),t._v(" "),v("h2",{attrs:{id:"_1-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[t._v("#")]),t._v(" 1. 简介")]),t._v(" "),v("p",[t._v("垃圾回收器是内存回收的具体实现，JDK自带的垃圾回收器已经完成集成垃圾回收和清理算法，业务程序可以通过设置参数选择垃圾回收器，虚拟机用到的7种经典的垃圾回收器如下表。根据适用内存区域不同，JDK自带的垃圾回收器可分为新生代回收器和老年代回收器，两者可以配合使用。新生代回收器用于堆空间中新生代区域的垃圾回收，老年代回收器用于堆空间中老年代区域的垃圾回收。G1是一种新型的堆内垃圾收集器，既可以用于新生代也可以用于老年代垃圾回收。")]),t._v(" "),v("h2",{attrs:{id:"_2-7种垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-7种垃圾回收器"}},[t._v("#")]),t._v(" 2. 7种垃圾回收器")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名称")]),t._v(" "),v("th",[t._v("说明")]),t._v(" "),v("th",[t._v("收集模式")]),t._v(" "),v("th",[t._v("分代适用类型")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Serial")]),t._v(" "),v("td",[t._v("单线程串行收集器")]),t._v(" "),v("td",[t._v("串行收集器")]),t._v(" "),v("td",[t._v("新生代")])]),t._v(" "),v("tr",[v("td",[t._v("ParNew")]),t._v(" "),v("td",[t._v("多线程并行Serial收集器")]),t._v(" "),v("td",[t._v("并行收集器")]),t._v(" "),v("td",[t._v("新生代")])]),t._v(" "),v("tr",[v("td",[t._v("Parallel Scavenge")]),t._v(" "),v("td",[t._v("并行吞吐量优先收集器")]),t._v(" "),v("td",[t._v("并行收集器")]),t._v(" "),v("td",[t._v("新生代")])]),t._v(" "),v("tr",[v("td",[t._v("Serial Old")]),t._v(" "),v("td",[t._v("Serial单线程收集器老年代版本")]),t._v(" "),v("td",[t._v("串行收集器")]),t._v(" "),v("td",[t._v("老年代")])]),t._v(" "),v("tr",[v("td",[t._v("CMS(Concurrent Mark Sweep)")]),t._v(" "),v("td",[t._v("并行最短停顿时间收集器")]),t._v(" "),v("td",[t._v("并发收集器")]),t._v(" "),v("td",[t._v("老年代")])]),t._v(" "),v("tr",[v("td",[t._v("Parallel Old")]),t._v(" "),v("td",[t._v("Parallel Scavenge并行收集器老年代版本")]),t._v(" "),v("td",[t._v("并行收集器")]),t._v(" "),v("td",[t._v("老年代")])]),t._v(" "),v("tr",[v("td",[t._v("G1")]),t._v(" "),v("td",[t._v("面向局部收集和基于Region内存布局的新型低延时收集器")]),t._v(" "),v("td",[t._v("并发/并行收集器")]),t._v(" "),v("td",[t._v("新生代/老年代")])])])]),t._v(" "),v("p",[t._v("下图展示了新生代GC和老年代GC配合使用方法，有连线的表示可以配合使用。注意ParNew和Parallel Old是不能同时使用的")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220429231123110.png",alt:"image-20220429231123110"}})]),t._v(" "),v("h2",{attrs:{id:"_3-如何选择合适的垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何选择合适的垃圾回收器"}},[t._v("#")]),t._v(" 3. 如何选择合适的垃圾回收器")]),t._v(" "),v("p",[t._v("垃圾回收器的选择方法没有通用的准则，要结合项目应用的实际并对GC运行数据的检测来决定。")]),t._v(" "),v("p",[t._v("根据收集模式经典垃圾回收器可分为三类：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，选择主要针对并行收集器和并发收集器。默认情况下，JDK1.5以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK1.5以后，JVM会根据当前"),v("a",{attrs:{href:"http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("系统配置"),v("OutboundLink")],1),t._v("进行判断。")]),t._v(" "),v("h3",{attrs:{id:"_3-1-垃圾回收器选择建议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-垃圾回收器选择建议"}},[t._v("#")]),t._v(" 3.1 垃圾回收器选择建议：")]),t._v(" "),v("ul",[v("li",[t._v("业务应用对吞吐量要求较高，对响应时间没有特别要求的，推荐使用并行收集器。如：科学计算和后台处理程序等等。")]),t._v(" "),v("li",[t._v("对响应时间要求较高的中大型应用程序，推荐使用并发收集器。如：web服务器等。")]),t._v(" "),v("li",[t._v("对应JDK版本1.8以上，多CPU处理器且内存资源不是瓶颈，建议优先考虑使用G1回收器。")]),t._v(" "),v("li",[t._v("单线程应用使用串行收集器。")])]),t._v(" "),v("h2",{attrs:{id:"_4-修改方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-修改方式"}},[t._v("#")]),t._v(" 4. 修改方式")]),t._v(" "),v("p",[t._v("以下表格汇总了各种回收器的分类、特点和修改参数：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("名称")]),t._v(" "),v("th",[t._v("修改参数")]),t._v(" "),v("th",[t._v("特点")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Serial")]),t._v(" "),v("td",[t._v("-XX:+UseSerialGC")]),t._v(" "),v("td",[t._v("用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，所有的用户线程必须暂停（Stop The World）。")])]),t._v(" "),v("tr",[v("td",[t._v("ParNew")]),t._v(" "),v("td",[t._v("-XX:+UseParNewGC")]),t._v(" "),v("td",[t._v("Serial的多线程版本，在单核CPU环境并不会比Serial更优，它默认开启的收集线程数和CPU核数，可以通过-XX:ParallelGCThreads来设置垃圾收集的线程数。")])]),t._v(" "),v("tr",[v("td",[t._v("Parallel Scavenge")]),t._v(" "),v("td",[t._v("-XX:+UseParallelGC jdk1.7、jdk1.8 新生代默认使用")]),t._v(" "),v("td",[t._v("用于新生代的多线程收集器，ParNew的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge的目标是达到一个可控制的吞吐量。通过-XX:MaxGCPauseMillis来设置收集器尽可能在多长时间内完成内存回收，通过-XX:GCTimeRatio来精确控制吞吐量。")])]),t._v(" "),v("tr",[v("td",[t._v("Serial Old")]),t._v(" "),v("td",[t._v("-XX:+UseSerialOldGC")]),t._v(" "),v("td",[t._v("Serial的老年代版本，采用标记-整理算法单线程收集器。")])]),t._v(" "),v("tr",[v("td",[t._v("CMS")]),t._v(" "),v("td",[t._v("-XX:+UseConMarkSweepGC")]),t._v(" "),v("td",[t._v("一种以最短回收停顿时间为目标的收集器，尽量做到最短用户线程停顿时间。CMS是基于标记-清除算法，所以垃圾回收后会产生空间碎片，通过-XX:UseCMSCompactAtFullCollection开启碎片整理（默认开启）。用-XX:CMSFullGCsBeforeCompaction设置执行多少次不压缩（不进行碎片整理）的Full GC之后，跟着来一次带压缩（碎片整理）的Full GC。-XX:ParallelCMSThreads：设定CMS的线程数量。")])]),t._v(" "),v("tr",[v("td",[t._v("Parallel Old")]),t._v(" "),v("td",[t._v("-XX:+UseParallelOldGC jdk1.7、jdk1.8老年代默认使用")]),t._v(" "),v("td",[t._v("Parallel Scavenge的老年代版本，使用-XX:ParallelGCThreads限制线程数量。")])]),t._v(" "),v("tr",[v("td",[t._v("G1")]),t._v(" "),v("td",[t._v("-XX:+UseG1GCjdk1.7以后才提供，jdk1.9默认")]),t._v(" "),v("td",[t._v("一款全新的收集器，兼顾并行和并发功能，能充分利用多CPU资源，运行期间不会产生内存碎片。通过-XX:ParallelGCThreads设置限制线程数量；-XX:MaxGCPauseMillis设置最大停顿时间。")])])])]),t._v(" "),v("h2",{attrs:{id:"参考文章"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://support.huaweicloud.com/tuningtip-kunpenggrf/kunpengtuning_12_0064.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("华为鲲鹏-选择合适的垃圾回收器"),v("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);