(window.webpackJsonp=window.webpackJsonp||[]).push([[995],{1371:function(_,v,t){"use strict";t.r(v);var a=t(26),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"拖拽排序后端设计思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拖拽排序后端设计思路"}},[_._v("#")]),_._v(" 拖拽排序后端设计思路")]),_._v(" "),t("h2",{attrs:{id:"_1-背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-背景"}},[_._v("#")]),_._v(" 1. 背景")]),_._v(" "),t("p",[_._v("最近做项目的时候遇到一个问题，就是前端需要对图片材料等拖拽排序。但排序后怎么存储？是批量保存所有顺序")]),_._v(" "),t("h2",{attrs:{id:"_2-需求描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-需求描述"}},[_._v("#")]),_._v(" 2. 需求描述")]),_._v(" "),t("ul",[t("li",[_._v("允许更改元素的排序；")]),_._v(" "),t("li",[_._v("允许新增数据，并更新现有排序；")]),_._v(" "),t("li",[_._v("允许删除数据，并更新现有排序。")])]),_._v(" "),t("h2",{attrs:{id:"_3-解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-解决方案"}},[_._v("#")]),_._v(" 3. 解决方案")]),_._v(" "),t("h3",{attrs:{id:"_3-1-方案一-全量更新元素位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-方案一-全量更新元素位置"}},[_._v("#")]),_._v(" 3.1 方案一： 全量更新元素位置")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("适用场景：")]),_._v(" "),t("p",[_._v("排序元素数量较少")])]),_._v(" "),t("li",[t("p",[_._v("原理：")]),_._v(" "),t("p",[_._v("每个元素拥有一个字段，表示元素当前排序的位置。通过前端排序，将排好的元素位置，一次性发送到后端。然后，后端统一更新所有元素的位置。")])]),_._v(" "),t("li",[t("p",[_._v("缺点")]),_._v(" "),t("p",[_._v("数据量过大，会导致频繁修改，造成数据库IO瓶颈")])]),_._v(" "),t("li",[t("p",[_._v("总结：")]),_._v(" "),t("p",[_._v("此方法仅适用于排序元素较少（例如，总元素为5~15个）的场景。对于大量数据排序并不适用")])])]),_._v(" "),t("h3",{attrs:{id:"_3-2-取中值法-推荐"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-取中值法-推荐"}},[_._v("#")]),_._v(" 3.2 取中值法（推荐）")]),_._v(" "),t("p",[_._v("原理与实现步骤：")]),_._v(" "),t("ol",[t("li",[_._v("创建元素时给元素赋默认位置（"),t("code",[_._v("pos")]),_._v("字段记录该值）。赋值规则为，当创建第一个元素时，默认位置赋值为65536，第二个元素为 "),t("code",[_._v("2 * 65536 = 13172")]),_._v("，增加第N个元素时，位置赋值为N*65536。")]),_._v(" "),t("li",[_._v("当拖拽改变元素位置时，更新 "),t("code",[_._v("pos")]),_._v("。更新规则如下：")])]),_._v(" "),t("ul",[t("li",[_._v("调整一个元素到两个元素中间时，"),t("code",[_._v("(pre_item.pos + after_item.pos）/ 2 = pos")])]),_._v(" "),t("li",[_._v("调整一个元素到第一个元素时， "),t("code",[_._v("old_first_item.pos / 2 = pos")])]),_._v(" "),t("li",[_._v("调整一个元素到最后一个元素时， "),t("code",[_._v("old_last_item.post + 65536 = pos")])])]),_._v(" "),t("ol",[t("li",[_._v("当前后两个元素的数值，不满足整数时，更新所有元素的排序。依次给每个元素的 "),t("code",[_._v("pos")]),_._v("赋新值。例如，第一位赋值65536，第二位为"),t("code",[_._v("2 * 65536")]),_._v("，第N位赋值N*65536。")])]),_._v(" "),t("p",[_._v("通过取中值的方法，改变元素的位置。当需要按序获取时，只需要对 "),t("code",[_._v("pos")]),_._v("进行排序，就可以获取元素的位置。")]),_._v(" "),t("h4",{attrs:{id:"_3-2-1-重排问题方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-重排问题方案"}},[_._v("#")]),_._v(" 3.2.1 重排问题方案")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("方案1：浮点数")]),_._v(" "),t("p",[_._v("可以使用浮点数储存 "),t("code",[_._v("pos")]),_._v("，但是需要考虑数据库存储的精度问题。而且，数值过小，会在前端丢失精度，元素排序会出现问题")])]),_._v(" "),t("li",[t("p",[_._v("方案2（推荐）：数值过小重排")]),_._v(" "),t("p",[_._v("如果在接口层，当检测到中值过小，则对所有元素进行重排，接口相应速度会存在问题")])]),_._v(" "),t("li",[t("p",[_._v("方案3：定时重排")]),_._v(" "),t("p",[_._v("利用定时任务每天对所有元素定时重排，来解决单次接口的性能问题。个人觉得这个方法，还是存在问题。若定时任务不及时，那么排序由于精度问题")])])]),_._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[_._v("#")]),_._v(" 参考文章")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/9ee708e43ebf",target:"_blank",rel:"noopener noreferrer"}},[_._v("拖拽排序后端设计与实现"),t("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=s.exports}}]);