(window.webpackJsonp=window.webpackJsonp||[]).push([[843],{1220:function(s,e,i){"use strict";i.r(e);var _=i(26),v=Object(_.a)({},(function(){var s=this,e=s.$createElement,i=s._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[i("h1",{attrs:{id:"redis面试-常规问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#redis面试-常规问题"}},[s._v("#")]),s._v(" Redis面试-常规问题")]),s._v(" "),i("h2",{attrs:{id:"_1-什么是redis-为什么用redis"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是redis-为什么用redis"}},[s._v("#")]),s._v(" 1  什么是Redis，为什么用Redis？")]),s._v(" "),i("p",[s._v("Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。")]),s._v(" "),i("ul",[i("li",[s._v("读写性能优异\n"),i("ul",[i("li",[s._v("Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。")])])]),s._v(" "),i("li",[s._v("数据类型丰富\n"),i("ul",[i("li",[s._v("Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。")])])]),s._v(" "),i("li",[s._v("原子性\n"),i("ul",[i("li",[s._v("Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。")])])]),s._v(" "),i("li",[s._v("丰富的特性\n"),i("ul",[i("li",[s._v("Redis支持 publish/subscribe, 通知, key 过期等特性。")])])]),s._v(" "),i("li",[s._v("持久化\n"),i("ul",[i("li",[s._v("Redis支持RDB, AOF等持久化方式")])])]),s._v(" "),i("li",[s._v("发布订阅\n"),i("ul",[i("li",[s._v("Redis支持发布/订阅模式")])])]),s._v(" "),i("li",[s._v("分布式\n"),i("ul",[i("li",[s._v("Redis Cluster")])])])]),s._v(" "),i("h2",{attrs:{id:"_2-为什么redis-是单线程的以及为什么这么快"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么redis-是单线程的以及为什么这么快"}},[s._v("#")]),s._v(" 2. 为什么Redis 是单线程的以及为什么这么快？")]),s._v(" "),i("ul",[i("li",[s._v("redis完全基于内存,绝大部分请求是纯粹的内存操作,非常快速.")]),s._v(" "),i("li",[s._v("数据结构简单,对数据操作也简单,redis中的数据结构是专门进行设计的")]),s._v(" "),i("li",[s._v("采用单线程模型, 避免了不必要的上下文切换和竞争条件, 也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗")]),s._v(" "),i("li",[s._v("使用了多路IO复用模型,非阻塞IO")]),s._v(" "),i("li",[s._v("使用底层模型不同,它们之间底层实现方式及与客户端之间的 通信的应用协议不一样,Redis直接构建了自己的VM机制,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求")])]),s._v(" "),i("h2",{attrs:{id:"_3-redis-一般有哪些使用场景"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis-一般有哪些使用场景"}},[s._v("#")]),s._v(" 3. Redis 一般有哪些使用场景？")]),s._v(" "),i("p",[s._v("可以结合自己的项目讲讲，比如")]),s._v(" "),i("ul",[i("li",[i("strong",[s._v("热点数据的缓存")])])]),s._v(" "),i("p",[s._v("缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。")]),s._v(" "),i("ul",[i("li",[i("strong",[s._v("限时业务的运用")])])]),s._v(" "),i("p",[s._v("redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。")]),s._v(" "),i("ul",[i("li",[i("strong",[s._v("计数器相关问题")])])]),s._v(" "),i("p",[s._v("redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。")]),s._v(" "),i("ul",[i("li",[i("strong",[s._v("分布式锁")])])]),s._v(" "),i("p",[s._v('这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。')]),s._v(" "),i("p",[s._v("在分布式锁的场景中，主要用在比如秒杀系统等。")])])}),[],!1,null,null,null);e.default=v.exports}}]);