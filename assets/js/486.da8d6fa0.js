(window.webpackJsonp=window.webpackJsonp||[]).push([[486],{869:function(r,_,t){"use strict";t.r(_);var v=t(26),e=Object(v.a)({},(function(){var r=this,_=r.$createElement,t=r._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"quartz原理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quartz原理分析"}},[r._v("#")]),r._v(" Quartz原理分析")]),r._v(" "),t("h2",{attrs:{id:"_1-quartz概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-quartz概念"}},[r._v("#")]),r._v(" 1. Quartz概念")]),r._v(" "),t("p",[r._v("Quartz是一个优秀的任务调度框架， 具有以下特点：")]),r._v(" "),t("ul",[t("li",[r._v("强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；")]),r._v(" "),t("li",[r._v("负载均衡")]),r._v(" "),t("li",[r._v("高可用")])]),r._v(" "),t("h3",{attrs:{id:"_1-1-调度器-scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-调度器-scheduler"}},[r._v("#")]),r._v(" 1.1 调度器：scheduler")]),r._v(" "),t("p",[r._v("任务调度的控制器，负责定时任务的调度，并且提供任务和触发器的增删改查等api方法。")]),r._v(" "),t("h3",{attrs:{id:"_1-2-任务-job"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-任务-job"}},[r._v("#")]),r._v(" 1.2 任务：job")]),r._v(" "),t("p",[r._v("job是实际被调度的任务，每个任务必须指定具体执行任务的实现类，实现类需要继承QuartzJobBean或者实现org.quartz.Job接口，具体的业务逻辑写在execute方法里面。\n是否支持并发的注解：@DisallowConcurrentExecution")]),r._v(" "),t("h3",{attrs:{id:"_1-3-触发器-trigger"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-触发器-trigger"}},[r._v("#")]),r._v(" 1.3 触发器：trigger")]),r._v(" "),t("p",[r._v("trigger用来定义调度时间的概念，即按什么样时间规则去触发任务。主要几种类型：")]),r._v(" "),t("ul",[t("li",[t("strong",[r._v("SimpleTrigger")]),r._v("：简单触发器，从某个时间开始，每隔多少时间触发，重复多少次。")]),r._v(" "),t("li",[t("strong",[r._v("CronTrigger")]),r._v('：使用cron表达式定义触发的时间规则，如"0 0 0,2,4 1/1 * ? *" 表示每天的0，2，4点触发。')]),r._v(" "),t("li",[t("strong",[r._v("DailyTimeIntervalTrigger")]),r._v("：每天中的一个时间段，每N个时间单元触发，时间单元可以是毫秒，秒，分，小时")]),r._v(" "),t("li",[t("strong",[r._v("CalendarIntervalTrigger")]),r._v("：每N个时间单元触发，时间单元可以是毫秒，秒，分，小时，日，月，年。")])]),r._v(" "),t("h4",{attrs:{id:"_1-3-1-trigger状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-trigger状态"}},[r._v("#")]),r._v(" 1.3.1 trigger状态：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("WAITING")])]),r._v(" "),t("li",[t("p",[r._v("ACQUIRED，")])]),r._v(" "),t("li",[t("p",[r._v("EXECUTING，")])]),r._v(" "),t("li",[t("p",[r._v("COMPLETE，")])]),r._v(" "),t("li",[t("p",[r._v("BLOCKED，")])]),r._v(" "),t("li",[t("p",[r._v("ERROR，")])]),r._v(" "),t("li",[t("p",[r._v("PAUSED，")])]),r._v(" "),t("li",[t("p",[r._v("PAUSED_BLOCKED，")])]),r._v(" "),t("li",[t("p",[r._v("DELETED")])])]),r._v(" "),t("h3",{attrs:{id:"_1-4-核心元素关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-核心元素关系"}},[r._v("#")]),r._v(" 1.4 核心元素关系")]),r._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719211631532.png",alt:"image-20220719211631532"}}),r._v(" "),t("h2",{attrs:{id:"_2-scheduler-调度线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-scheduler-调度线程"}},[r._v("#")]),r._v(" 2. Scheduler 调度线程")]),r._v(" "),t("p",[r._v("Scheduler 调度线程主要有两个：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("执行常规调度的线程")]),r._v(" "),t("p",[r._v("常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务")])]),r._v(" "),t("li",[t("p",[r._v("执行 misfired trigger 的线程。")]),r._v(" "),t("p",[r._v("Misfire 线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理。")])])]),r._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212131722.png",alt:"image-20220719212131722"}}),r._v(" "),t("h3",{attrs:{id:"_2-1-quartz-调度线程流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-quartz-调度线程流程图"}},[r._v("#")]),r._v(" 2.1 Quartz 调度线程流程图")]),r._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212254193.png",alt:"image-20220719212254193"}}),r._v(" "),t("h2",{attrs:{id:"_3-未正常触发的任务-misfire-job"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-未正常触发的任务-misfire-job"}},[r._v("#")]),r._v(" 3. 未正常触发的任务：misfire job")]),r._v(" "),t("p",[r._v("没有在正常触发时间点触发的任务。主要由以下几种情况导致：")]),r._v(" "),t("ul",[t("li",[r._v("触发时间在应用不可用的时间内，比如重启")]),r._v(" "),t("li",[r._v("上次的执行时间过长，超过了下次触发的时间")]),r._v(" "),t("li",[r._v("任务被暂停一段时间后，重新被调度的时间在下次触发时间之后")])]),r._v(" "),t("p",[r._v("处理misfire job的策略，需要在创建trigger的时候配置，每种trigger对应的枚举值都不同，具体在接口里面有定义。CronTrigger有2种处理misfire的策略：")]),r._v(" "),t("table",[t("thead",[t("tr",[t("th",[r._v("处理策略")]),r._v(" "),t("th",[r._v("描述")])])]),r._v(" "),t("tbody",[t("tr",[t("td",[r._v("MISFIRE_INSTRUCTION_FIRE_ONCE_NOW")]),r._v(" "),t("td",[r._v("立即触发一次")])]),r._v(" "),t("tr",[t("td",[r._v("MISFIRE_INSTRUCTION_DO_NOTHING")]),r._v(" "),t("td",[r._v("忽略，不处理，等待下次触发")])])])]),r._v(" "),t("p",[r._v("之间的关系：")]),r._v(" "),t("p",[r._v("scheduler由工厂类SchedulerFactory创建，主要负责job和trigger的持久化管理，包括新增、删除、修改、触发、暂停、恢复调度、停止调度等；")]),r._v(" "),t("p",[r._v("一个job可以关联多个trigger，但是一个trigger只能关联一个job。")]),r._v(" "),t("h2",{attrs:{id:"_4-quzrtz单机模式-原理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-quzrtz单机模式-原理分析"}},[r._v("#")]),r._v(" 4. Quzrtz单机模式 原理分析")]),r._v(" "),t("ol",[t("li",[r._v("scheduler是一个计划调度器容器（总部），容器里面可以盛放众多的JobDetail和trigger，当容器启动后，里面的每个JobDetail都会根据trigger按部就班自动去执行。")]),r._v(" "),t("li",[r._v("JobDetail是一个可执行的工作，它本身可能是有状态的。")]),r._v(" "),t("li",[r._v("Trigger代表一个调度参数的配置，什么时候去调。")]),r._v(" "),t("li",[r._v("当JobDetail和Trigger在scheduler容器上注册后，形成了装配好的作业（JobDetail和Trigger所组成的一对儿），就可以伴随容器启动而调度执行了。")]),r._v(" "),t("li",[r._v("scheduler是个容器，容器中有一个线程池，用来并行调度执行每个作业，这样可以提高容器效率。")])]),r._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719212814763.png",alt:"image-20220719212814763"}}),r._v(" "),t("h2",{attrs:{id:"_5-集群模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-集群模式"}},[r._v("#")]),r._v(" 5. 集群模式")]),r._v(" "),t("p",[r._v("Quartz的集群模式指的是"),t("strong",[r._v("一个集群下多个节点管理同一批任务的调度")]),r._v("，"),t("strong",[r._v("通过共享数据库的方式实现")]),r._v("，保证同一个任务到达触发时间的时候，"),t("strong",[r._v("只有一台机器去执行该任务")]),r._v("。"),t("strong",[r._v("每个节点部署一个单独的quartz实例，相互之间没有直接数据通信。")])]),r._v(" "),t("h3",{attrs:{id:"_5-1-quartz集群模式部署图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-quartz集群模式部署图"}},[r._v("#")]),r._v(" 5.1 Quartz集群模式部署图")]),r._v(" "),t("p",[t("img",{attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220719213026199.png",alt:"image-20220719213026199"}})]),r._v(" "),t("h3",{attrs:{id:"_5-2-集群模式原理分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-集群模式原理分析"}},[r._v("#")]),r._v(" 5.2 集群模式原理分析")]),r._v(" "),t("p",[r._v("quartz集群是通过数据库表来感知其他的应用的，各个节点之间并没有直接的通信。"),t("strong",[r._v("只有使用持久的JobStore才能完成Quartz集群")]),r._v("。\n数据库表：以前有12张表，现在只有11张表，现在没有存储listener相关的表，多了QRTZ_SIMPROP_TRIGGERS表：")]),r._v(" "),t("table",[t("thead",[t("tr",[t("th",[r._v("Table name")]),r._v(" "),t("th",[r._v("Description")])])]),r._v(" "),t("tbody",[t("tr",[t("td",[r._v("QRTZ_CALENDARS")]),r._v(" "),t("td",[r._v("存储Quartz的Calendar信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_CRON_TRIGGERS")]),r._v(" "),t("td",[r._v("存储CronTrigger，包括Cron表达式和时区信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_FIRED_TRIGGERS")]),r._v(" "),t("td",[r._v("存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_PAUSED_TRIGGER_GRPS")]),r._v(" "),t("td",[r._v("存储已暂停的Trigger组的信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_SCHEDULER_STATE")]),r._v(" "),t("td",[r._v("存储少量的有关Scheduler的状态信息，和别的Scheduler实例")])]),r._v(" "),t("tr",[t("td",[t("strong",[r._v("QRTZ_LOCKS")])]),r._v(" "),t("td",[t("strong",[r._v("存储程序的悲观锁的信息")])])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_JOB_DETAILS")]),r._v(" "),t("td",[r._v("存储每一个已配置的Job的详细信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_SIMPLE_TRIGGERS")]),r._v(" "),t("td",[r._v("存储简单的Trigger，包括重复次数、间隔、以及已触的次数")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_BLOG_TRIGGERS")]),r._v(" "),t("td",[r._v("Trigger作为Blob类型存储")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_TRIGGERS")]),r._v(" "),t("td",[r._v("存储已配置的Trigger的信息")])]),r._v(" "),t("tr",[t("td",[r._v("QRTZ_SIMPROP_TRIGGERS")]),r._v(" "),t("td")])])]),r._v(" "),t("h4",{attrs:{id:"_5-2-1-qrtz-locks行锁表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-qrtz-locks行锁表"}},[r._v("#")]),r._v(" 5.2.1 QRTZ_LOCKS行锁表")]),r._v(" "),t("p",[r._v("QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表,包括以下几个锁：")]),r._v(" "),t("ul",[t("li",[r._v("CALENDAR_ACCESS")]),r._v(" "),t("li",[r._v("JOB_ACCESS")]),r._v(" "),t("li",[r._v("MISFIRE_ACCESS")]),r._v(" "),t("li",[r._v("STATE_ACCESS")]),r._v(" "),t("li",[r._v("TRIGGER_ACCESS")])]),r._v(" "),t("h4",{attrs:{id:"_5-2-2-负责任务调度的几个线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-2-负责任务调度的几个线程"}},[r._v("#")]),r._v(" 5.2.2 负责任务调度的几个线程")]),r._v(" "),t("p",[r._v("负责任务调度的几个线程：")]),r._v(" "),t("ol",[t("li",[r._v("任务执行线程：通常使用一个线程池(SimpleThreadPool)维护一组线程，负责实际每个job的执行。")]),r._v(" "),t("li",[r._v("Scheduler调度线程QuartzSchedulerThread ：轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。")]),r._v(" "),t("li",[r._v("处理misfire job的线程MisfireHandler：轮训所有misfire的trigger，原理就是从数据库中查询所有下次触发时间小于当前时间的trigger，按照每个trigger设定的misfire策略处理这些trigger。")])]),r._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[r._v("#")]),r._v(" 参考文章")]),r._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/e95d6764b4d9",target:"_blank",rel:"noopener noreferrer"}},[r._v("Quartz原理分析"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);