(window.webpackJsonp=window.webpackJsonp||[]).push([[324],{700:function(t,a,_){"use strict";_.r(a);var s=_(26),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"rabbitmq概念补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq概念补充"}},[t._v("#")]),t._v(" RabbitMQ概念补充")]),t._v(" "),_("h2",{attrs:{id:"_1-消息持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-消息持久化"}},[t._v("#")]),t._v(" 1. 消息持久化")]),t._v(" "),_("p",[_("strong",[t._v("Rabbit队列和交换器默认情况下重启服务器会导致消息丢失")]),t._v("，那么怎么保证Rabbit在重启的时候不丢失呢？答案就是消息持久化。")]),t._v(" "),_("h3",{attrs:{id:"_1-1-持久化条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-持久化条件"}},[t._v("#")]),t._v(" 1.1 持久化条件")]),t._v(" "),_("p",[t._v("当你把消息发送到Rabbit服务器的时候，你需要选择你是否要进行持久化，但这并不能保证Rabbit能从崩溃中恢复，想要Rabbit消息能恢复必须满足3个条件：")]),t._v(" "),_("ol",[_("li",[t._v("投递消息的时候durable设置为true，消息持久化，代码：channel.queueDeclare(x, true, false, false, null)，参数2设置为true持久化；")]),t._v(" "),_("li",[t._v("设置投递模式deliveryMode设置为2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENT_TEXT_PLAIN,x)，参数3设置为存储纯文本到磁盘；")]),t._v(" "),_("li",[t._v("消息已经到达持久化交换器上；")]),t._v(" "),_("li",[t._v("消息已经到达持久化的队列；")])]),t._v(" "),_("h3",{attrs:{id:"_1-2-持久化工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-持久化工作原理"}},[t._v("#")]),t._v(" 1.2 持久化工作原理")]),t._v(" "),_("p",[t._v("Rabbit会将你的持久化消息写入磁盘上的持久化日志文件，等消息被消费之后，Rabbit会把这条消息标识为等待垃圾回收。")]),t._v(" "),_("h3",{attrs:{id:"_1-3-持久化的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-持久化的缺点"}},[t._v("#")]),t._v(" 1.3 持久化的缺点")]),t._v(" "),_("p",[t._v("消息持久化的优点显而易见，但缺点也很明显，那就是性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量，尽管使用SSD硬盘可以使事情得到缓解，但他仍然吸干了Rabbit的性能，当消息成千上万条要写入磁盘的时候，性能是很低的。")]),t._v(" "),_("p",[t._v("所以使用者要根据自己的情况，选择适合自己的方式。")]),t._v(" "),_("h2",{attrs:{id:"_2-虚拟主机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟主机"}},[t._v("#")]),t._v(" 2. 虚拟主机")]),t._v(" "),_("p",[t._v("每个Rabbit都能创建很多vhost，我们称之为虚拟主机，"),_("strong",[t._v("每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_2-1-vhost特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-vhost特性"}},[t._v("#")]),t._v(" 2.1 vhost特性")]),t._v(" "),_("ol",[_("li",[t._v("RabbitMQ默认的vhost是“/”开箱即用；")]),t._v(" "),_("li",[t._v("多个vhost是隔离的，多个vhost无法通讯，并且不用担心命名冲突（队列和交换器和绑定），实现了多层分离；")]),t._v(" "),_("li",[t._v("创建用户的时候必须指定vhost；")])]),t._v(" "),_("h3",{attrs:{id:"_2-2-vhost操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-vhost操作"}},[t._v("#")]),t._v(" 2.2 vhost操作")]),t._v(" "),_("p",[t._v("可以通过rabbitmqctl工具命令创建：")]),t._v(" "),_("blockquote",[_("p",[t._v("rabbitmqctl add_vhost[vhost_name]")])]),t._v(" "),_("p",[t._v("删除vhost：")]),t._v(" "),_("blockquote",[_("p",[t._v("rabbitmqctl delete_vhost[vhost_name]")])]),t._v(" "),_("p",[t._v("查看所有的vhost：")]),t._v(" "),_("blockquote",[_("p",[t._v("rabbitmqctl list_vhosts")])]),t._v(" "),_("h2",{attrs:{id:"参考文章"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/vipstone/p/9275256.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RabbitMQ系列（二）深入了解RabbitMQ工作原理及简单使用"),_("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=v.exports}}]);