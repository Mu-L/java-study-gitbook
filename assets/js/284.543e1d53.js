(window.webpackJsonp=window.webpackJsonp||[]).push([[284],{663:function(t,v,n){"use strict";n.r(v);var _=n(26),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,n=t._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"druid源码学习-十-druiddatasource中的一些计数器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#druid源码学习-十-druiddatasource中的一些计数器"}},[t._v("#")]),t._v(" Druid源码学习（十）-DruidDataSource中的一些计数器")]),t._v(" "),n("p",[t._v("在 Druid 连接池的工作过程中，会用到一些计数器对Druid的情况进行判断。然后根据计数器的数据采取一系列操作，整理如下:")]),t._v(" "),n("h2",{attrs:{id:"_1-统计类的计数器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-统计类的计数器"}},[t._v("#")]),t._v(" 1. 统计类的计数器")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("变量名")]),t._v(" "),n("th",[t._v("类型")]),t._v(" "),n("th",[t._v("说明")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("connectCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("getConnectionInternal被调用之后就会增加，意味着连接被get的次数。")])]),t._v(" "),n("tr",[n("td",[t._v("closeCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("连接调用recycle中，包括回收、关闭等情况，成功之后会增加，标识连接关闭的次数。")])]),t._v(" "),n("tr",[n("td",[t._v("recycleCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("连接调用recycle成功之后才会增加，不包括在回收过程中关闭的情况。标识连接真正回收的次数。")])]),t._v(" "),n("tr",[n("td",[t._v("removeAbandonedCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("连接调用removeAbandoned成功之后才会增加，标识连接跟踪泄露机制的执行次数。")])]),t._v(" "),n("tr",[n("td",[t._v("notEmptyWaitCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("连接调用pollLast或者tackLast之后就会增加，实际上是触发notEmpty.await的的次数.")])]),t._v(" "),n("tr",[n("td",[t._v("notEmptySignalCount")]),t._v(" "),n("td",[t._v("long")]),t._v(" "),n("td",[t._v("连接触发notEmpty的signal的次数。")])]),t._v(" "),n("tr",[n("td",[t._v("discardCount")]),t._v(" "),n("td",[t._v("volatile long")]),t._v(" "),n("td",[t._v("调用discard成功之后的次数。")])])])]),t._v(" "),n("p",[t._v("上述long类型的计数器，全部只会增加，不会减少，在Druid工作的过程中进行统计和监控作用。")]),t._v(" "),n("h2",{attrs:{id:"_2-状态相关的计数器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-状态相关的计数器"}},[t._v("#")]),t._v(" 2.状态相关的计数器")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("变量名")]),t._v(" "),n("th",[t._v("类型")]),t._v(" "),n("th",[t._v("说明")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("poolingCount")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("DruidConnectionHolder[] connections数组中连接的数量。")])]),t._v(" "),n("tr",[n("td",[t._v("activeCount")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("Map<DruidPooledConnection, Object> activeConnections 中的连接数量。")])]),t._v(" "),n("tr",[n("td",[t._v("notEmptyWaitThreadCount")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("连接被取出之后，触发notEmpty进行wait线程的数量。")])]),t._v(" "),n("tr",[n("td",[t._v("activePeak")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("activeCount出现的峰值。")])]),t._v(" "),n("tr",[n("td",[t._v("poolingPeak")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("poolingCount出现的峰值。")])]),t._v(" "),n("tr",[n("td",[t._v("createTaskCount")]),t._v(" "),n("td",[t._v("int")]),t._v(" "),n("td",[t._v("创建连接线程数的计数器。")])])])]),t._v(" "),n("h2",{attrs:{id:"_3-相关的判断逻辑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-相关的判断逻辑"}},[t._v("#")]),t._v(" 3. 相关的判断逻辑：")]),t._v(" "),n("p",[t._v("poolingCount < initialSize 时，创建连接以达到初始化连接数。\npoolingCount >= maxActive 时，回收的连接会被拒绝放入connections中。")]),t._v(" "),n("p",[t._v("activeCount + poolingCount >= maxActive时， empty.await()，创建连接的线程会被取消。\nactiveCount + poolingCount <= minIdle 时，通知emptySignal(),通知继续创建连接。\nkeepAlive && poolingCount + activeCount < minIdle 时，再shrink方法中needFill为true,会触发通知emptySignal(),继续创建连接。\nactiveCount + poolingCount + createTaskCount >= maxActive 时，开启了createScheduler，则会取消createScheduler的创建任务。\nactiveCount <= minIdle 时，触发emptySignal()，创建连接。")]),t._v(" "),n("h2",{attrs:{id:"_4-存储connection的容器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-存储connection的容器"}},[t._v("#")]),t._v(" 4. 存储Connection的容器")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("变量名")]),t._v(" "),n("th",[t._v("类型")]),t._v(" "),n("th",[t._v("说明")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("connections")]),t._v(" "),n("td",[t._v("DruidConnectionHolder[]")]),t._v(" "),n("td",[t._v("连接存放的数组。")])]),t._v(" "),n("tr",[n("td",[t._v("keepAliveConnections")]),t._v(" "),n("td",[t._v("DruidConnectionHolder[]")]),t._v(" "),n("td",[t._v("keepAlive连接存放的数组。只会在shrink中开启了keepalive才会使用。")])]),t._v(" "),n("tr",[n("td",[t._v("evictConnections")]),t._v(" "),n("td",[t._v("DruidConnectionHolder[]")]),t._v(" "),n("td",[t._v("需要关闭的连接存放的数组。shrink中该数组中的连接都会被关闭掉。")])]),t._v(" "),n("tr",[n("td",[t._v("activeConnections")]),t._v(" "),n("td",[t._v("Map<DruidPooledConnection, Object>")]),t._v(" "),n("td",[t._v("getConnection之后，存放的容器。")])])])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20220525230547564.png",alt:"image-20220525230547564"}})]),t._v(" "),n("h2",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/dhaibo1986/article/details/121430733?spm=1001.2014.3001.5502",target:"_blank",rel:"noopener noreferrer"}},[t._v("Druid源码阅读10-DruidDataSource中的一些计数器"),n("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);