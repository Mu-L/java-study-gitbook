import{_ as i,W as r,X as p,Y as e,Z as l,$ as s,a0 as h,D as t}from"./framework-0cf5f349.js";const c={},n=h('<h1 id="es面试-elasticsearch面试-场景篇" tabindex="-1"><a class="header-anchor" href="#es面试-elasticsearch面试-场景篇" aria-hidden="true">#</a> ES面试 - ElasticSearch面试（场景篇）</h1><h2 id="_1-elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少" tabindex="-1"><a class="header-anchor" href="#_1-elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少" aria-hidden="true">#</a> 1. elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少</h2><blockquote><p>面试官：想了解应聘者之前公司接触的 ES 使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。</p></blockquote><p>解答：</p><p>如实结合自己的实践场景回答即可。</p><p>比如：ES 集群架构 13 个节点，索引根据通道不同共 20+索引，根据日期，每日</p><p>递增 20+，索引：10 分片，每日递增 1 亿+数据，</p><p>每个通道每天索引大小控制：150GB 之内。</p><h2 id="_2-调优手段" tabindex="-1"><a class="header-anchor" href="#_2-调优手段" aria-hidden="true">#</a> 2. 调优手段</h2><p>仅索引层面调优手段：</p><h3 id="_2-1-设计阶段调优" tabindex="-1"><a class="header-anchor" href="#_2-1-设计阶段调优" aria-hidden="true">#</a> 2.1 设计阶段调优</h3><ol><li><p>根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</p></li><li><p>使用别名进行索引管理；</p></li><li><p>每天凌晨定时对索引做 force_merge 操作，以释放空间；</p></li><li><p>采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink操作，以缩减存储；</p></li><li><p>采取 curator 进行索引的生命周期管理；</p></li><li><p>仅针对需要分词的字段，合理的设置分词器；</p></li><li><p>Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..</p></li></ol><h3 id="_2-2-写入调优" tabindex="-1"><a class="header-anchor" href="#_2-2-写入调优" aria-hidden="true">#</a> 2.2 写入调优</h3><ol><li><p>写入前副本数设置为 0；</p></li><li><p>写入前关闭 refresh_interval 设置为-1，禁用刷新机制；</p></li><li><p>写入过程中：采取 bulk 批量写入；</p></li><li><p>写入后恢复副本数和刷新间隔；</p></li><li><p>尽量使用自动生成的 id。</p></li></ol><h3 id="_2-3-查询调优" tabindex="-1"><a class="header-anchor" href="#_2-3-查询调优" aria-hidden="true">#</a> 2.3 查询调优</h3><ol><li><p>禁用 wildcard；</p></li><li><p>禁用批量 terms（成百上千的场景）；</p></li><li><p>充分利用倒排索引机制，能 keyword 类型尽量 keyword；</p></li><li><p>数据量大时候，可以先基于时间敲定索引再检索；</p></li><li><p>设置合理的路由机制。</p></li></ol><h3 id="_2-4-其他调优" tabindex="-1"><a class="header-anchor" href="#_2-4-其他调优" aria-hidden="true">#</a> 2.4 其他调优</h3><p>部署调优，业务调优等。</p><p>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</p><h2 id="_3-elasticsearch-的倒排索引是什么" tabindex="-1"><a class="header-anchor" href="#_3-elasticsearch-的倒排索引是什么" aria-hidden="true">#</a> 3. elasticsearch 的倒排索引是什么</h2><blockquote><p>面试官：想了解你对基础概念的认知。</p><p>解答：通俗解释一下就可以。</p></blockquote><p>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。</p><p>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表,即为倒排索引。</p><p>有了倒排索引，就能<strong>实现 o（1）时间复杂度的效率检索文章</strong>了，极大的提高了检索效率。</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221226225351132.png" alt="image-20221226225351132" tabindex="0" loading="lazy"><figcaption>image-20221226225351132</figcaption></figure><p>学术的解答方式：</p><p>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</p><p>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。</p><blockquote><p>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：</p><ul><li><p>1、空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</p></li><li><p>2、查询速度快。O(len(str))的查询时间复杂度。</p></li></ul></blockquote><h2 id="_4-elasticsearch-索引数据多了怎么办-如何调优-部署" tabindex="-1"><a class="header-anchor" href="#_4-elasticsearch-索引数据多了怎么办-如何调优-部署" aria-hidden="true">#</a> 4. elasticsearch 索引数据多了怎么办，如何调优，部署</h2><blockquote><p>面试官：想了解大数据量的运维能力。</p></blockquote><p>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，</p><p>这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户</p><p>检索或者其他业务受到影响。</p><p>如何调优，正如问题 1 所说，这里细化一下：</p><h3 id="_4-1-动态索引层面" tabindex="-1"><a class="header-anchor" href="#_4-1-动态索引层面" aria-hidden="true">#</a> <strong>4.1 动态索引层面</strong></h3><p>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索引的模板格式为：blog_index_时间戳的形式，每天递增数据。</p><p>这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的32 次幂-1，索引存储达到了 TB+甚至更大。</p><p>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p><h3 id="_4-2-存储层面" tabindex="-1"><a class="header-anchor" href="#_4-2-存储层面" aria-hidden="true">#</a> <strong>4.2 存储层面</strong></h3><p>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。</p><p>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，</p><p>节省存储空间和检索效率。</p><h3 id="_4-3-部署层面" tabindex="-1"><a class="header-anchor" href="#_4-3-部署层面" aria-hidden="true">#</a> <strong>4.3 部署层面</strong></h3><p>一旦之前没有规划，这里就属于应急策略。</p><p>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。</p><h2 id="_5-elasticsearch-是如何实现-master-选举的" tabindex="-1"><a class="header-anchor" href="#_5-elasticsearch-是如何实现-master-选举的" aria-hidden="true">#</a> <strong>5.elasticsearch 是如何实现 master 选举的</strong></h2><blockquote><p>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。</p></blockquote><p>解答：</p><h3 id="_5-1-前置前提" tabindex="-1"><a class="header-anchor" href="#_5-1-前置前提" aria-hidden="true">#</a> 5.1 前置前提：</h3><p>1、只有候选主节点（master：true）的节点才能成为主节点。</p><p>2、最小主节点数（min_master_nodes）的目的是防止脑裂。</p><h3 id="_5-2-选举流程" tabindex="-1"><a class="header-anchor" href="#_5-2-选举流程" aria-hidden="true">#</a> 5.2 选举流程</h3><p>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否则返回 null。选举流程大致描述如下：</p><ul><li>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值</li></ul><p>​ discovery.zen.minimum_master_nodes；</p><ul><li>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。</li></ul><p>题外话：获取节点 id 的方法。</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221226231708330.png" alt="image-20221226231708330" tabindex="0" loading="lazy"><figcaption>image-20221226231708330</figcaption></figure><h2 id="_6-详细描述一下-elasticsearch-索引文档的过程" tabindex="-1"><a class="header-anchor" href="#_6-详细描述一下-elasticsearch-索引文档的过程" aria-hidden="true">#</a> 6. 详细描述一下 Elasticsearch 索引文档的过程</h2><blockquote><p>面试官：想了解 ES 的底层原理，不再只关注业务层面了。</p></blockquote><p>解答：</p><p>这里的索引文档应该理解为文档写入 ES，创建索引的过程。</p><p>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。</p><p>记住官方文档中的这个图。</p><figure><img src="https://zszblog.oss-cn-beijing.aliyuncs.com/zszblog/image-20221226231822138.png" alt="image-20221226231822138" tabindex="0" loading="lazy"><figcaption>image-20221226231822138</figcaption></figure><ul><li><p>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）</p></li><li><p>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。</p></li><li><p>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。</p></li></ul><p>如果面试官再问：第二步中的文档获取分片的过程？</p><p>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的</p><p>过程。</p><p>shard = hash(_routing) % (num_of_primary_shards)</p><h2 id="_7-详细描述一下-elasticsearch-搜索的过程" tabindex="-1"><a class="header-anchor" href="#_7-详细描述一下-elasticsearch-搜索的过程" aria-hidden="true">#</a> 7. 详细描述一下 Elasticsearch 搜索的过程？</h2><blockquote><p>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。</p></blockquote><p>解答：</p><p>搜索拆解为“query then fetch” 两个阶段。</p><h3 id="_7-1-query-阶段的目的-定位到位置-但不取。" tabindex="-1"><a class="header-anchor" href="#_7-1-query-阶段的目的-定位到位置-但不取。" aria-hidden="true">#</a> 7.1 <strong>query 阶段的目的</strong>：定位到位置，但不取。</h3><p>步骤拆解如下：</p><p>1、假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本</p><p>分片中）的一个。</p><p>2、每个分片在本地进行查询，结果返回到本地有序的优先队列中。</p><p>3、第 （2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</p><h3 id="_7-2-fetch-阶段的目的-取数据。" tabindex="-1"><a class="header-anchor" href="#_7-2-fetch-阶段的目的-取数据。" aria-hidden="true">#</a> 7.2 <strong>fetch 阶段的目的</strong>：取数据。</h3><p>路由节点获取所有文档，返回给客户端。</p><h2 id="_8-elasticsearch-在部署时-对-linux-的设置有哪些优化方法" tabindex="-1"><a class="header-anchor" href="#_8-elasticsearch-在部署时-对-linux-的设置有哪些优化方法" aria-hidden="true">#</a> 8. Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h2><blockquote><p>面试官：想了解对 ES 集群的运维能力。</p></blockquote><p>解答：</p><ol><li><p>关闭缓存 swap;</p></li><li><p>堆内存设置为：Min（节点内存/2, 32GB）;</p></li><li><p>设置最大文件句柄数；</p></li><li><p>线程池+队列大小根据业务需要做调整；</p></li><li><p>磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</p></li></ol><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>',88),o={href:"https://zhuanlan.zhihu.com/p/102500311",target:"_blank",rel:"noopener noreferrer"};function d(u,_){const a=t("ExternalLinkIcon");return r(),p("div",null,[n,e("p",null,[e("a",o,[l("新年手打，24道进阶必备Elasticsearch 面试真题（建议收藏！）"),s(a)])])])}const b=i(c,[["render",d],["__file","elasticsearch-interview-scene.html.vue"]]);export{b as default};
